## JS知识总结

### 1：JS事件循环

js是一个单线程的语言，但是浏览器能很好的处理异步请求，这是因为浏览器有自己的执行线程，且JS有自己的事件循环机制

##### 浏览器执行线程

浏览器是多进程的，浏览器的每个tab标签都代表一个独立的进程，其中浏览器的渲染进程（浏览器的内核）属于浏览器多进程的一种，主要负责页面渲染，脚本执行，事件处理等；其包含的线程有：GUI渲染线程（负责渲染页面，解析HTML，css构成DOM树）、JS引擎线程，事件触发线程，定时器触发线程，定时器触发线程，HTTP请求等主要线程；

##### JS的事件循环机制

+ 主线程：JS引擎执行的线程，这个线程只有一个，页面渲染，函数处理都在这个主线程上执行；

+ 工作线程：也称幕后线程，这个线程可能存在浏览器或者JS引擎内，与主线程是分开的，处理文件，网络请求，定时器等异步事件；
+ 任务队列：所有任务都可以分为同步任务或者异步任务，同步任务一般会进入到主线程中执行，而异步任务（如ajax，settimeout等）会通过任务队列的机制（先进先出）来进行协调；



#### 同步任务和异步任务分别进入不同的执行环境，同步的进入主进程，异步的进入任务队列，主进程的事件执行完毕之后，会去任务队列读取对应的任务，推入主进程中执行，这个过程不断地重复就是我们说的JS的事件循环；



在事件循环中，每一次的循环操作被称为tick，每一次的tick任务处理模型是比较复杂的，关键步骤可以总结如下：

1. 在此次tick中选择最先进入队列的任务，如果有则执行一次
2. 检查是否存在微任务（Microtasks），如果存在则不停的执行，直至清空microtask queue;
3. 更新render
4. 住线程重复执行上述步骤



#### 任务task通常分为两类，分别是Macro Task（宏任务）和Micro Task（微任务），每个宏任务结束后都要清空微任务



宏任务主要包含：script（整体代码），setTimeout，setInterval，I/O，UI交互事件，SetImmediate（Node.js环境）

微任务主要包含：Promise，MutaionObserver，process.nextTick（Node.js环境）



### 2：BFC概念

Formatting context（格式化上下文），它是页面中的一个渲染区域，并且有一套渲染规则，他决定了其子元素如何定位，，以及和其他元素的关系和相互作用。常见的Formatting context有BFC（块级格式化上下文）和IFC（行内格式化上下文）



BFC（Block formatting context块级格式化上下文）。它是一个独立的渲染区域，只有block-level box 参与，并且与这个区域外部毫不相干；

BFC布局规则：

1. ​	内部box会在垂直方向，一个接一个的放置；
2. Box垂直方向上的距离由margin决定。属于同一个BFC的两个相邻的Box，margin会发生重叠；
3. 每个元素的左边margin与外层Block的border相接触（即使存在浮动也是如此）；
4. BFC就是页面上的一个独立的容器，容器里的子元素不会影响到外层的元素，反之外面的元素也不会影响里面的元素；
5. BFC的区域不会与浮动的Box重合
6. 计算BFC元素的高度时，浮动元素也参与计算；

哪些元素会生成BFC

1. 根元素
2. float不为none的元素
3. position为absolute或者fixed
4. display为inline-block，table-cell，table-caption，flex，inline-flex;
5. overflow不为visible(hidden,scroll,auto)



#### 以下情况需要使用BFC

##### 1.当需要自适应两栏布局时

```
<body>
    <div class="aside"></div>
    <div class="main"></div>
</body>
body {
    width: 300px;
    position: relative;
}
.aside {
    width: 100px;
    height: 150px;
    float: left;
    background: #f66;
}
.main {
	overflow: hidden;
    height: 200px;
    background: #fcc;
}
aside设置了float:left；main需要触发BFC，设置overflow：hidden;才能缩小main的宽度实现两栏布局
```



##### 2.当子元素都设置了float时，外层父元素需要触发BFC（设置overflow: hidden;），在计算高度时，才能把子元素的高度也算上



##### 3.防止垂直的margin重叠

当两个垂直的兄弟元素都设置了margin时，会发生margin重叠的情况，此时需要给另一个兄弟元素添加一个父标签，并给父标签触发BFC(overflow: hidden;)，此时margin就会是两者相加后的值

##### 一般我们为了防止margin重叠，会只给一个元素设置margin值



### 3：JS防抖和节流

#### 1：防抖

1. 当我们要去监听浏览器滚动条的时候，每滚动一次，可能会执行多次监听函数，这样会消耗浏览器很多性能
2. 当某个按钮被重复多次点击，函数会默认执行多次

解决办法：如果用户在操作之后，隔一段时间没有继续操作，设置一个定时器，让函数在某个时间区间内只执行一次，一段时间后才能再次执行，为了不污染全局作用域的变量，可以使用闭包来实现

```
function debounce(fn, delay){
	let timer = null; // 使用闭包
	return ()=>{
        if(timer){
            clearTimeout(timer);
        }else {
            timer = setTimeout(fn, delay)  // fn要执行的函数，delay延时的时间段
        }
	}
}
```



#### 2：节流

如果使用以上的防抖方案来处理问题，那么当用户不停的滚动滚动条，或者不停的点击按钮，那么函数将永远不会执行，此时，就需要使用节流方案了

```
function throttle(fn, delay){
	let flag = false;
	return ()=>{
		if(!flag){
			return false;
		}
		flag = false
		setTimeout(()=>{
			fn();
			flag = true
		}, delay)
	}
}
```

其他应用场景：

1. 搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当作用户输入完成后，开始搜索，具体使用哪种方案还是看业务需求
2. 页面resize事件，常用于需要做页面适配的时候，根据需要最终呈现的页面情况进行DOM渲染（这种情况一般使用防抖，因为只需要判断最后一次的变化情况）

### 4：HTTP缓存机制

了解HTTP缓存之前先得明确几个术语：

1. 缓存命中率：从缓存中得到的数据请求数与所有请求数的比率，理想状态越高越好;
2. 过期内容：超过设置的有效时间，被标记为 “陈旧” 的内容。通常过期内容不能用于回复客户端的;请求，必须重新向源服务器请求新的内容，或者验证缓存的内容是否任然准备；
3. 验证：验证缓存中的内容是否任然有效，验证通过的话，刷新过期的时间；
4. 失效：失效就是把内容从缓存中移除，当内容发生改变时就必须移除失效内容;

浏览器缓存分类：

浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：

1. 浏览器会根据HTTP请求头信息来判断是否命中强缓存，如果命中，则直接从缓存拿数据，并不会将请求发送到服务器；
2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器，服务器来判断浏览器的本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源；
3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存；

+ ##### 命中强缓存时，浏览器并不会将请求发送到服务器，Chrome开发者工具中看到HTTP请求返回状态码为200，但是Size列会显示：from cache或者from disk

+ ##### 缓存过期时间，用来指定资源到期时间，是服务端的具体的时间点。





### 6：让chrome支持小于12px的字体大小

1. 使用带前缀的属性：-webkit-text-size-adjust: none;
2. 使用CSS缩放属性：-webkit-transform: scale(0.8);

 

### 7：JS严格模式

严格模式的产生是为了形成与正常代码不同的语义，支持严格模式与不支持严格模式的浏览器在执行代码时会采取不同的行为，在没有对运行环境展开特性测试来验证对于严格模式相关方面支持的情况下，就算采用了严格模式也不一定会得到预期的效果，，严格模式和非严格模式的代码可以共存

严格模式对正常的JS语义做了一些更改：

1. 严格模式通过抛出错误来消除一些原有的静默错误
2. 严格模式修复了一些导致JS引擎难以执行优化的缺陷：相同的代码，严格模式可能比非严格模式下运行的更快
3. 严格模式禁用了在ECMAScript的未来版本中可能会定义的语法



### 8：网站SEO优化

1. 网站title，搜索引擎在抓取网页数据的时候，最先读取的就是网页title，title一般不超过80个字符，而且词语中间要用英文的 “-” 隔开，因为计算力对英文的敏感度很高
2. description（网站内容摘要）：<meta name="description" content=".....">
3. keywords（网站关键词）：<meta name="keywords" content=".....">
4. 语义化html：比如标题（h1-h6），段落（p），页面的头部（header），内容（content, aside, footer, section...），尽量不要使用纯样式化的标签（如：b, i, font, u, strong...）， 改用css来设置样式
5. 非装饰化图片必须加alt属性：<img>标签的alt属性指定了替代文本，用于在图像无法显示的时候，代替图像显示在浏览器中的内容；alt属性的作用：1：增强内容的相关性；2：提高关键词密度
6. 外链：在别的网站导入自己网站的链接，一个高质量的外链可以给网站带来很好的流量
7. 向各大搜索引擎登录入口提交尚未收录的站点
8. 将重要的html的代码放在最前面，搜索引擎的顺序是从上到下的，要保证重要内容一定会被抓取
9. 提高网站的速度



### 9：关键渲染路径，让网站优化有规律可循（可使用Google自带的lighthouse工具测试网站的性能）

1. 关键字节数（实际响应给用户所需要的字节）：浏览器用一次往返获取渲染页面所需的html，这就是它所需要的一切，此时关键长度为1，当加上css和JS脚本文件时，由于没有返送外部请求，关键路径长度没有变，但是渲染速度变慢，因为HTML的大小变大
2. 关键文件数：http1会对下载的文件数量有限制，http2没有限制，但是会有TCP往返限制，任何一次的往返可传输的最大数据量是14KB，对于所有的包括HTML，css，JS脚本都是如此
3. 关键路径数：浏览器用一次往返获取渲染页面所需的html，这就是它所需要的一切，此时关键长度为1，一次外部请求就会让路径数增加1



### 10：前端性能指标分析

google提出网站用户体验的三大核心指标，分别为：

1. LCP（代表页面的速度指标，一般来说页面最大元素的快速载入会让用户感觉性能很好）
2. FID（代表页面的交互指标，快的交互响应会让用户觉得网页很流畅）
3. CLS（代表页面的稳定指标，累计位移偏移，这个指标在手机上尤为重要）



优化指标

+ 资源优化：优化FP（首屏绘制），FCP（首屏内容绘制），LCP（最大内容绘制）指标

1. 压缩文件，使用Tree-shaking删除无用代码
2. 服务端配置Gzip进一步再压缩文件体积
3. 资源按需加载
4. 通过chrome Devtools分析首屏不需要的css文件，以此来精简css
5. 内联关键的css代码
6. 使用CDN加载资源dns-prefetch预解析DNS的IP地址
7. 对资源使用preconnect，以便预先进行IP解析，TCP握手，TLS握手
8. 缓存文件，对首屏数据做离线缓存
9. 图片优化，包括用CSS代替图片，剪裁适配屏幕的图片大小，小图片使用base64或者png格式的，支持webp就尽量使用webp，渐进式加载图片



+ 网络优化：优化FP，FCP，LCP指标

1. 这块内容大多可以让运维帮忙配置，升级至最新的网络协议通常能让网站加载速度更快，例如http2.0，TLS1.3，或者直接使用QUIC协议~



+ 优化耗时任务：优化TTI（首次可交互时间），FID（首次输入延迟），TBT（阻塞总时间）

1. 使用web worker将耗时任务丢到子线程中，这样才能让主线程在不卡顿的情况下处理JS任务，调度任务  +  时间切片，这块技术在React16中有使用到，简单来说就是给不同的任务分配优先级，然后将一段长任务切片，这样能尽量保证任务只在浏览器的空闲时间中执行，而不卡顿主线程



+ 不要动态的插入内容：优化CLS指标

1. 使用骨架屏给用户一个预期的内容框架，突兀的显示内容体验不会很好，图片切勿不设置长宽，而是使用占位图给用户一个图片的预期位置，不要在现有的内容中插入内容，起码给出一个预留的位置



