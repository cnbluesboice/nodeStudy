### 题集

#### 1：css

1. 谈一下BFC

   ```
   BFC是一个独立的布局环境，其中的元素是不受外界影响的
   如何创建BFC：float的值不是none；position的值不是static和relative；overflow的值不为visibility；
BFC可以解决这些问题：margin重合，清除浮动等；
   ```
   
   

#### 2：JS

1. call，apply和bind方法的区别

   ```
   call：接受一个参数集合，第一个参数是一个对象，其他参数是调用者的实参
   call的作用如下：
   实现继承：
   function Person(age){
   	this.age = age
   }
   function Teacher(age, name){
   	Person.call(this, age);
   	this.name = name
   }
   调用匿名函数:
   let obj={
   	name: "eason",
   	age: 20,
   }
   for(let key in obj){
   	(function(){
           console.log(this.key);
   	}).call(obj, key)
   })
   
   使用call调用函数，并指定上下文的this
   function handle(){
   	console.log(this.name, this.age);
   }
   const obj={
   	name: "eason",
   	age: 20,
   }
   handle.call(obj)
   检测数据类型
   Object,proptotype.toString.call("").slice(8, -1);  // string
   Object,proptotype.toString.call(true).slice(8, -1);  // Boolean
   ```

   ```
   apply: 接收两个参数，第一个参数是一个对象，第二个参数是调用者的实参（为数组）
   apply作用如下：
   合并数组，且不改变原数组arr1(concat方法返回一个新数组，apply返回原数组)
   arr1.push.apply(arr1, arr2)
   
   当循环一个超长的数组时，可以将数组切分成小块来处理
   例如从一个超长的数组中找出最小值
   function getMinOfArray(arr){
   	const min = infinity; // 定义一个参数，用来存储最小值
   	const square = 100;
   	for(let i=0; i< arr.length; i += square){
   	  // 先找出0-99的最小值，下一次循环就找100-199的最小值，然后每一次的最小值与上一次的最小值进行比较
   	  const submin = Math.min.apply(null, arr.slice(i, Math.min(i + square, min)));
   	  const min = Math.min(submin, min);
   	}
   	return min;
   }
   
   使用apply来链接构造器(可以给全局构造器绑定一些方法和属性，供全局使用，但无法与一些内置对象一起使用，如Date)
   Function.prototype.constructor=function(args){
   	const newObj = Object.create(this.prototype);
   	this.apply(newObj, args);
   	return newObj;
   }
   使用闭包来实现
   Function.prototype.constructor=function(args){
   	const that = this;
   	const newConstructor=function(){
   		that.apply(this, args);
   	}
   	newConstructor.prototype = this.prototype;
   	return new newConstructor();
   }
   
   ```

   ```
   bind方法：会创建一个新的函数，第一个参数为对象，其他参数为新函数的实参
   ```

   

2. DOM事件委托是什么，用途（可以顺带结合react的事件合成）

   事件机制：事件是在系统内部发生的动作，系统会在事件被触发时，加载程序定义的某种动作机制；

   事件委托：就是利用事件冒泡机制，只指定一个事件处理程序，就可以管理某一类所有事件；

   优点：节省监听数（内存），可以监听动态元素

   DOM事件流分为：捕获阶段，目标阶段，冒泡阶段

   事件捕获：窗口document-->目标

   事件冒泡：目标 --> 回到窗口document

   监听事件方式：addEventListener(事件名称, 处理函数, true/false)，第三个参数让开发者自选择是使用事件捕获还是事件冒泡（true为捕获，false为冒泡）

   事件对象event中的target和currentTarget：target是用户操作的元素，currentTarget是事件绑定的元素

   阻止事件冒泡：event.stopPropagation();

   阻止默认事件：event.preventDefault();（如a链接的跳转，浏览器的默认事件）

   结合react中的合成事件：react利用事件冒泡，将所有的事件绑定在document对象上（以组件名称和事件名称为键存储），事件在触发时，会根据组件名称的事件名称调用对应的事件处理函数

3. 谈一下闭包（可以结合防抖和节流）（闭包的优缺点，以及使用场景）

   闭包：就是在内层函数中可以访问外层函数的作用域；

   作用：在es6的class出来之前，可以使用闭包来模拟私有方法和私有属性，此时counter内的属性和方法都只能被return出来的函数访问

   ```
   const counter = (function(){
   	var privateAttr = 10;
   	function privateFun(num){
   	 	return num + privateAttr
   	}
   	return {
   		increment: function(num){
   			privateFun(num)
   		}
   		log: function(){
   			console.log(privateAttr)
   		}
   	}
   })()
   counter.privateFun();
   counter.log();
   ```

   优点：可以实现一些特殊的场景需求，例如防抖和节流

   缺点：影响处理速度，降低脚本性能

   防抖：在第一次触发事件时不会立即执行函数，在规定的时间之后没有二次触发才会执行，意思就是说在短时间内多次触发事件，事件执行函数只执行一次

   节流：在短时间内多次触发事件，那么在函数执行一次之后，在规定的时间后才能再次执行

   ```
   // 防抖
   function debounce(fn, delay){
   	const timer = null;
   	return function(){
           if(timer){
   			clearTimeout(timer);
           }else {
           	timer = setTimeout(fn, delay)
           }
   	}
   }
   // 节流
   function throttle(fn, delay){
   	const flag = false;
   	return function(){
   		if(!flag){
   			return false; // 如果开关关闭了，就不执行下面的函数
   		}else {
   			flag = false; // 如果持续触发，flag一直赋值为false，一直停留在上面的判断那里
   			setTimeout(()=>{
   				fn();
   				flag = true; // 定时器执行完之后，打开开关
   			}, delay);
   		}
   	}
   }
   // 什么时候用防抖，什么时候用节流
   // 如果事件触发频率高，但是有停顿时，可以选择防抖
   // 如果事件连续不断的高频触发时，只能选择节流
   ```

   

4. new关键字做了什么

   + 创建一个对象
   + 将新对象的proto原型属性指向构造函数的prototype对象
   + 将构造函数的作用域赋值给新对象（也就是this指向新对象）
   + 返回新对象

5. JS的事件流模型都有什么

   包含事件捕获和事件冒泡，详细参照答案**2**

6. JS如何实现继承（es5和es6）

   ```
   // es5方式
   // 1：原型链继承，将子类的原型对象指向父类构造函数的实例
   function Father(){
   	this.name = "eason"
   }
   function Son(){}
   Son.prototype = new Father();
   
   // 2：构造函数继承，在子类中调用父类的构造函数
   function Father(){
   	this.name = "eason"
   }
   function Son(){
   	Father.call(this, arguments);
   	this.age = 20;
   }
   ```

   ```
   // es6方式
   class Father {
   	static name = "eason";
   	constructor(name, age){
   		this.name = name;
   		this.age = age;
   	}
   	fn(){
   		console.log(this.name, this.age);
   	}
   }
   // 定义子类，继承父类
   class Son extends Father {
   	constructor(name, age){
   		super(name, age);
   	}
   }
   ```

   

7. JS中捕获异常的方法

   JS 中使用try catch finally捕获异常，try与catch或者finally配合使用，可三者一起使用；

   try块中放置要执行的代码；

   catch块对try块中抛出的异常（包括出错的信息，堆栈，出错的文件等，无法捕获语法错误）进行捕获；

   finally块中的代码不管try中的代码有无异常都会执行；

8. 如何终止ajax请求（例如一个页面还未请求完，要进入另一个页面）

   原生XHR对象和jQuery对象上面都有一个abort方法，直接调用就可以取消请求

   axios中取消ajax请求：axios中自带一个cancelToken的API，具体实现代码如下：

   ```
   重新封装axios，在axios请求拦截那里做如下操作
   1：先在window上绑定一个数组，用来存放历史页面路由数据
   window.__axiosPromiseArr=[];
   2：在axios请求拦截那里在请求配置对象config上绑定cancelToken
   axios.interceptors.request.use((config)=>{
   	config.cancelToken = new axios.CancelToken(cancel=>{
   		window.__axiosPromiseArr.push({
   			url: config.url,
   			cancel,
   		})
   	})
   })
   
   在页面使用时
   1：先封装公共方法：
   export function cancelRequest(){
   	if(window.__axiosPromiseArr){
   		window.__axiosPromiseArr.forEach((ele, index)=>{
   			ele.cancel();
   			delete window.__axiosPromiseArr(index);
   		})
   	}
   }
   2：组件中引入方法后，在创建阶段（constructor）,调用方法
   import { cancelRequest } from "utils/common";
   constructor(){
   	super();
   	cancelRequest()
   }
   ```

   

9. 对象的深浅拷贝的区别，以及实现方法

   浅拷贝：是拷贝对象的值，新对象与原对象公用一个内存空间

   深拷贝：拷贝对象的地址，新对象与源对象互不干扰

   实现深拷贝的方法：

   ```
   1：先转成字符串之后再转成对象
   obj2 = JSON.parse(JSON.stringify(obj1))
   2：使用迭代递归法（for in）
   function deepCopy(obj1){
   	let obj2 = {};
   	for(let key in obj1){
   		const keyType = Object.prototype.toString.call(Obj1[key]).slice(8, -1);
   		obj2[k] = keyType === "Array" || keyType === "Object" ? deepCopy(obj1[key]) : obj1[key]
   	}
   	return obj2;
   }
   ```

   

10. 关于同步和异步

    异步传输是面向字符的传输，单位是字符；

    同步传输是面向比特的传输，单位是帧，它传输的时候要求接收方和发送方的时钟保持一致；

11. ajax工作原理

    Ajax的原理简单的来说就是通过XMLHttpRequest对象来向服务器发送异步请求，从服务器获取数据，然后用JS来操作DOM更新页面。

    步骤：1：创建一个XMLHttpRequest对象

    ​			2：调用open方法链接服务器

    ​			3：调用send方法发送请求

    ​			4：通过onreadystatechange事件监听响应状态，在事件处理函数中通过异步对象的responseText获取响应信息（readyState为4，status为200时表示响应成功）

12. JS预解析

    用var声明的变量和用function声明的函数都会被预解析，变量的提升只提升声明，变量的定义不会被提升，函数被提升时声明和定义都会被声明；例子如下

    ```
    fn(); // undefined
    var num = 10;
    fn(); // 10
    function fn(){
    	console.log(num);
    	num = 20;
    }
    fn(); // 20
    ```

    

13. JS的垃圾回收机制与V8引擎

    垃圾回收机制：就是找到那些不再使用的变量，释放其占用的内存；

    垃圾回收的方式：

    ​	1：标记清除：在变量进入环境和离开环境时分别加上：进入标记和离开标记；被标记上离开环境的变量会被垃圾收集器清理

    ​	2：引用计数：跟踪记录每个值被引用的次数；当声明了一个变量并将一个引用类型的值赋值给这个变量时，这个值的引用次数就是1，如果这个值同时又被赋值给另一个变量，则引用次数计为2；

    引用计数方式会带来内存泄漏：当两个值被互相引用的话，就会导致这两个值的引用次数永远不会为0，无法回收

    v8引擎：编程语言分为解释型语言和编译型语言，解释型语言是一边解释一边执行的，编译型语言是先完全编译后再执行，这样的话执行速度会比解释型语言快一些；但是解释型语言的响应速度会比编译型语言快；由于JS是解释型语言，为了解决解释型语言的执行速度慢的问题，v8引擎就是为了解决这个问题的；

14. 事件循环机制（主进程，任务队列，宏任务和微任务）

    任务队列：所有的任务可以分为同步任务和异步任务，同步任务就是立即执行的任务，直接进入到主进程，异步任务会进入任务队列；

    同步任务和异步任务进入不同的执行环境，同步任务进入主进程，异步任务进入事件队列，主线程的任务执行完毕之后会开始执行事件队列中的任务；此过程不断重复就是事件循环。

    任务分为宏任务和微任务，每个宏任务执行完毕之后，都要清空所有的微任务。

    微任务主要包含：Promise，process.nextTick（node环境）；

    宏任务主要包含：JS整体代码，定时器，UI交互事件，setImmediate（node环境）

15. 常见web安全问题

    1：SQL注入：将SQL插入到web表单中，获取数据库的数据

    我们之前预想的SQL 语句是:

    ```
    SELECT * FROM user WHERE username='admin' AND psw='password'
    ```

    但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：

    ```
    SELECT * FROM user WHERE username='admin' --' AND psw='xxxx'
    ```

    （SQL中“－－”是注释后面的内容的意思，当用户输入的用户名中带有“－－”时，用户可以输入任意密码登录）

    可以添加用户名和密码的正则校验来防止攻击

    2：XSS（跨站脚本攻击）：攻击者恶意在web页面插入执行代码

    可以设置白名单，告诉浏览器哪些外部资源可以加载：设置http请求的header的Content-Security-Policy

    3：CSRF（跨站请求伪造）：利用用户的已登录身份，来完成非法操作

    请求时带上token可以解决这个问题；

16. localStorage和sessionStorage。以及session和cookie（他们同样的有跨域限制）

    localStorage：永久性存储，必须手动删除，同浏览器不同页面之间可以共享，不同浏览器之间不可以共享

    sessionStorage：会话存储，不同浏览器和不同页面之间都不能共享，关闭浏览器或者页面就会删除

17. 跨域的原因，以及如何解决跨域（如何使用axios解决跨域）

    原因：浏览器的同源策略会导致跨域，协议，域名和端口中有一个不同都会导致跨域；

    解决办法：

    ​	1：设置代理（webpack设置proxy），

    ​	2：后端设置跨域资源共享cors（如果是普通的请求可以直接后端设置cors（后端设置Access-Control-Allow-Origin），如果要携带cookie的话，前后端都需要设置：withCredentials 为true），

    ​	3：jsonp

    ​	4：nginx服务代理

18. es6的新特性

    新增变量声明let和const;

    新增解构赋值

    对象和数组的新增方法keys()， values()，entrys()

    Promise对象

    Generateor函数

    async函数

    class语法实现继承

    说明：Generator函数是Es6提出的一种异步编程的解决方案，async是Generator函数的语法糖，Promise是对async和await的封装

19. MVC和MVVM思想

    MVC(model view controller)：view（界面），model（提供数据），controller（把数据给界面显示），MVC的数据是单向的

    MVVM（model view viewModel）:view（界面），model（提供数据），viewModel（view和model的绑定器，实现数据的双向绑定，view和viewModel之间采取数据绑定，绑定是双向的，避免开发人员写一些同步view和viewModel的重复逻辑）

    在MVVM的实现中，引入了一个Binder层，创建了一个视图的抽象，将视图中的状态和行为抽离出来；

    vue提供了一个具有MVVM风格的双向数据绑定的框架，它的核心是MVVM中的vieｗModel，ViewModel负责连接view和model，保证视图的一致性；在vue中，VM和view，VM和model之间都是双向数据绑定，实现方式就是数据劫持；

    react是单向数据流，加上redux状态管理，可以实现MVVM风格的开发；

    所以总结来说，vue参考了MVVM的思想，但是没有完全遵循MVVM，react只是View层

20. 数据劫持

    ```
    Object.defineProperty(data, prop, descriptor)
    data: 目标对象
    prop：被重新定义或者获取的属性名称
    descriptor：属性的可描述特性
    
    descriptor对象包含如下特性：
    {
    	value: 属性值
    	writable：为false则不能被重写
    	enumerable：是否能在for……in……或者Object.keys()中被枚举出来
    	configurable：若为false，则任何删除属性，或者修改如下特性（writable，enumerable， configurable ）的操作将会无效
    	get：属性被访问时会触发此函数，
    	set：属性被修改时会触发此函数
    }
    ```

    

    ```
    const obj={
        name: "eason"
    }
    Object.keys(obj).forEach((key)=>{
        Object.defineProperty(obj, key, {
            enumerable:true,
            configurable:true,
            get:function(){
                console.log('get');
            },
            set:function(){
                console.log('监听到数据发生了变化');
            }
        })
    })
    obj.name="chenling"
    
    ```

    

#### 3：react

1. react的工作原理说明，以及优缺点

   见react原理说明MD文档

2. react的生命周期（16.3之后废除了哪些生命周期，原因是什么）

   + componentWillMount：会导致首页白屏，且在此时订阅事件后，react会在componentWillUnmount中取消事件的订阅，但是同一组件在调用componentWillMount后，并不一定会调用componentWillUnmount，就会产生内存泄漏的问题，影响性能；
   + componentWillReceiveProps：之前的版本中，如果state和props关联密切的话，需要去componentWillReceiveProps中判断前后的props是否相同，不同就更新state，这么做会破坏state的单一数据源，增加组件的重绘次数（使用场景：比如一个Tab，本来是组件内部的一个状态，但如果从组件外部进入的时候需要跳转到特定的Tab，此时props和state就会互相冲突）

3. 什么是受控组件和高阶组件（HOC），纯组件（PureComponent）

   受控元素：可以通过state或者props设置/修改其初始值的元素，非受控元素与之相反

   受控组件：

4. redux的工作原理以及工作流程，react-thunk的原理

5. react路由（工作流程以及原理）

6. react优化

7. 虚拟DOM

8. 函数组件与类组件的区别

9. refs的作用是什么

10. react的事件处理（合成事件）

11. state和props的区别

12. 什么是JSX

13. react Hooks是什么，如何使用，以及有什么优势



#### 4：vue

1. vue的生命周期
2. vue有哪些指令，v-if和v-show的区别
3. vue的父子组件传值
4. vueX的使用，工作流程，以及原理
5. v-model双向数据绑定原理
6. vue自定义指令（使用方法以及生命周期）
7. vue中监听属性watch和计算属性computed的区别
8. 请说一下computed中的getter和setter
9. vue导航守卫和导航钩子有哪些
10. vue-router的工作流程和原理
11. vue路由的两种模式history和hash，他们的区别
12. 如何给vue定义全局方法
13. keep-alive有关的生命周期和其使用方法以及原理
14. diff算法
15. 如何优化首页加载
16. 如何实现路由懒加载
17. vue中如何监听一个对象内部分变化
18. $nextTick如何使用，有什么作用
19. vue如何异步更新队列
20. active-class是哪个组件的属性
21. $route和$router的区别
22. vue minix混入的用法
23. vue3新增哪些内容
24. 如何在vue项目中实现按需加载？
25. vue slot 的用法和原理



#### 5：webpack

1. webpack与grunt、gulp的不同？
2. 如何可以自动生成webpack配置？
3. 什么是bundle，chunk，module
4. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？
5. 有哪些常见的Loader和Plugin？他们是解决什么问题的，Loader和Plugin的不同？
6. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全
7. webpack的热更新是如何做到的？说明其原理？
8. 如何利用webpack来优化前端性能？（提高性能和体验）
9. 如何提高webpack的构建速度？
10. 怎么配置单页应用？怎么配置多页应用？
11. npm打包时需要注意哪些？如何利用webpack来更好的构建？
12. 什么是长缓存，webpack中是如何做到长缓存的
13. 什么是Tree-shaking？css可以Tree-shaking吗？
14. dll动态链接库（这个是面试过程中的优化点，把不变的第三方库，独立打包，开发的时候直接引用打包好的，提高开发效率）
15. webpack代码切割
16. source-map（这个也是项目里面一个很好的优化点）



#### 6：优化

1. vue项目优化解决方案
2. react优化解决方案



#### 7：网络

1. http与https的工作原理，常见http状态码
2. tcp与ip的原理
3. URL从输入到页面响应做了哪些事情
4. http缓存



#### 8：node

1. node的特征，以及优缺点
2. commonJS的导入和导出与es6的区别
3. AMD CMD规范的区别
4. 同步和异步的区别，如何避免回调地狱
5. 说一下node的事件循环
6. node如何创建一个服务器并与MySQL进行连接
7. 什么是错误优先的回调函数（第一个参数返回错误）
8. 什么是promise，generater，async和await 以及promise之间的关系
9. node的模块机制。require的模块加载机制
10. 描述一下整个异步I/O的流程
11. 简述一下node的多进程架构
12. 弄清楚node的中间件



#### 9：工作中遇到了那些问题，是如何解决的

