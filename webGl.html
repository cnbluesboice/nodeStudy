<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas id="webGL"></canvas>
</body>
<script>
    const canvas = document.getElementById("webGL");
    const gl = canvas.getContext("webgl");
    gl.canvas;

    gl.activeTexture(111)
    // console.log(canvas, "canvas");
    console.log(gl, "gl");
    // console.log(gl.canvas, "gl.canvas");
    // console.log(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS, "gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS");


    // const offscreen = new OffscreenCanvas(256, 256);
    // const glTest = offscreen.getContext("webgl");
    // glTest.canvas; // OffscreenCanvas
    // console.log(glTest.canvas, "glTest.canvas");


    // this.imgList = [
    //     { "1": { type_dictText: "1111", imgList: ["url1", "url2"] } },
    //     { "2": { type_dictText: "1111", imgList: ["url1", "url2"] } },
    //     { "5": { type_dictText: "1111", imgList: ["url1", "url2"] } }
    // ]
    // // 再生成一个如下只有type的数组
    // this.typeList = ["1", "2", "5"]
    // // 然后再v-for循环this.typeList， 此时的index与this.imgList是一一对应的关系，你可以通过如下方式拿到type对应的数据
    // this.imgList[typeIndex][typeItem]  // 若typeIndex为0的话，此时拿到的是"1"对应的数组
    // // 然后再去v-for循环this.imgList[typeIndex][typeItem]，渲染对应的DOM结构
</script>

</html>